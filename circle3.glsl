#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.141592

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

void main() {
  vec2 coord = gl_FragCoord.xy / u_resolution.xy; // 각 픽셀들의 좌표값 normalize
  coord = coord * 2. - 1.; // 원점을 캔버스의 좌하단 -> 캔버스 정가운데로 옮기기 위해 각 픽셀들의 좌표값 Mapping
  coord.x *= u_resolution.x / u_resolution.y; // 캔버스를 resizing해도 도형에 왜곡이 없도록 좌표값에 해상도 비율값을 곱함

  // 해당 픽셀이 갖고 있는 중심점으로부터 각의 크기
  float a = atan(coord.y, coord.x);

  // 해당 픽셀과 중심 사이의 거리(벡터의 길이라고 보면 되겠지)
  // float d = distance(vec2(0.), coord); // 이미 원점을 중심점으로 옮겼으므로, 원의 중심점 값이 (0.0, 0.0)임
  float d = length(coord); // 이렇게 픽셀 좌표값만 인자로 넣어서 length() 로 길이값을 받는 게 성능상 더 빠름.

  // sin 함수에 넣어주는 각 픽셀들의 각도값에 매 프레임마다 증가하는 u_time 값을 더해주게 되면,
  // 매 프레임마다 바람개비를 그릴 때 모든 픽셀들이 이전 프레임보다 증가된 각도값으로
  // sin 값, 즉 반지름값을 구하기 때문에, 바람개비가 회전하는 애니메이션을 그리게 됨!
  // WebGL을 사용해서 그려준다면 타임스탬프값을 이용하면 되겠지! 
  a += u_time;

  // 기본적으로, 원의 각도상 한바퀴는 2PI 잖아
  // 그런데 2PI면 sin 곡선이 위로 한 번 올라갔다가 밑으로 내려올 때의 각도값의 주기에 해당하지?
  // 여기서 만약, 위로 한번 올라갈 때 나타나는 게 날개 하나라면, 날개가 총 3개 그려져야 하니까
  // 위로 3번 올라가야겠지! 그러면 각도값도 3배로 부풀려줘야 sin 곡선이 위로 세 번 올라가겠지!
  a *= 4.;

  // 반지름 값 구하기
  // 6PI 까지의 각도 변화에 따른 주기적인 sin값을 리턴받아서 반지름값을 구함.
  float r = sin(a);

  // 바람개비의 경계선이 뚜렷하도록 그려줘야 하니까
  // 각 픽셀과 원의 중심을 잇는 벡터의 거리값(d)이 해당 벡터의 각도값(a)로 계산한 sin값(r), 즉 반지름보다 작으면 0, 크면 1을 리턴함.
  // 바람개비 경계선 안쪽(sin값을 기준으로 한 반지름보다 가까운 픽셀들)은 vec3(1.)로 색깔이 찍힐 것이고, 
  // 경계선 바깥쪽(반지름보다 먼 픽셀들)은 vec3(0.)로 색깔이 찍힐 것임. 
  vec3 col = vec3(step(r, d));

  gl_FragColor = vec4(col, 1.);
}

/*
  바람개비 그리기 vs 동심원 그리기


  동심원은 중심으로부터 원의 경계상의 각 포인트들이 이루는 각도 (atan값이지?)와 무관하게
  동일한 길이의 반지름을 갖게 됨.

  반면, 바람개비는 육안으로만 보아도
  원의 중심으로부터 각 포인트들의 좌표가 경계상의 각 포인트들이 이루는 각도(atan)에 따라
  반지름의 길이가 들쑥날쑥 변동하는 모습을 보이고 있지 

  그런데 모양이 부드러운 곡선의 모습을 그리며 바람개비를 그리고 있는 것을 보니
  추측컨데, 이 곡선은 분명 sin 곡선 그래프를 갖고 있는 게 아닐까? 라고 생각해볼 수 있는 것이지!

  이러한 추론을 바탕으로 직접 코드를 다시 짜보는 것!
*/

/*
  sin의 리턴값이 바람개비 날개를 그리는 원리


  동심원과 달리 바람개비는 경계선의 점들과 중심점 사이의 거리, 즉 반지름이 들쑥날쑥 변함. 
  어떻게 변하냐?
  
  해당 좌표가 원의 중심으로부터 이루는 각의 크기에 따라서 
  반지름이 증가했다가 감소하는 주기를 가짐.
  
  이때, 각의 크기는 0도 ~ 360도(2PI)로 한바퀴 돌게 되고, 
  각도값이 한바퀴 돌 때의 'sin의 리턴값'도 증가했다가 감소하는데, 
  이 사인값을 반지름값으로 지정한 것이지!
  
  한바퀴 돌 때의 사인값의 주기가 바람개비의 날개 1개를 그리게 됨.
  그런데 이 예제에서는 바람개비 날개가 총 3개가 필요하지?
  그래서 각 픽셀들의 각도값을 3배로 곱해줘서
  각 픽셀들의 사인값의 주기(즉, 반지름값의 주기)가 3번 반복되도록 해준 것임. 
  
  -> 이 주기 횟수(즉, float a에 곱해주는 값)가 늘어나면 늘어날수록 
  바람개비의 날개 개수도 늘어나게 됨!
  즉, 각도를 1번 곱하면 바람개비가 1개 생기고, 2번 곱하면 2개, 3번 곱하면 3개, 100번 곱하면 100개가 생긴다는 것.
  sin값의 주기가 곱해지는 횟수만큼 반복되기 때문에!

  근데 이 바람개비 모양을 보고 어떻게 반지름이 sin값의 주기로 변한다고 추측했을까?
  날개의 모양이 부드러운 곡선 형태로 이루고 있기 때문에 sin이나 cos 아닐까 생각했던 것이지
*/

/*
  참고로, 삼각형 그리기 예제도 원문코드에는 존재하지만, 
  코드가 복잡하고 설명하는 과정도 난해해서 생략했다고 함...

  원래 캔버스나 WebGL로 그리면 삼각형 그리는 게 가장 쉬운건데...
  이 강의 자체가 Fragment Shader 로만 그림을 그리다 보니까 삼각형 하나 그리기도 어렵나 봄..
  실제로 셰이더 사용할 때 삼각형을 직접 그려야 할 정도로 복잡한 코드는 사용하지 않는다고 함.

  강의 자체가 셰이더토이 처럼 프래그먼트 셰이더로 모든 걸 그려보는 느낌인 것 같음.
*/